//
//  ViewController.m
//  CurseWork
//
//  Created by KonstEmelyantsev on 4/17/16.
//  Copyright © 2016 KonstEmelyantsev. All rights reserved.
//

#import "ViewController.h"
#import "AnimationViewController.h"

@interface ViewController ()

{
    Mat frame; //current frame
    //Mat fgMaskMOG; //fg mask generated by MOG method
    Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
    
    //Ptr<BackgroundSubtractor> pMOG; //MOG Background subtractor
    Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
}

@property (nonatomic, strong) AnimationViewController *avc;

@end

@implementation ViewController

@synthesize videoCamera;

- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.videoCamera = [[CvVideoCamera alloc] initWithParentView:imageView];
    self.videoCamera.defaultAVCaptureDevicePosition = AVCaptureDevicePositionFront;
    self.videoCamera.defaultAVCaptureSessionPreset = AVCaptureSessionPreset352x288;
    self.videoCamera.defaultAVCaptureVideoOrientation = AVCaptureVideoOrientationPortrait;
    self.videoCamera.defaultFPS = 30;
    self.videoCamera.grayscaleMode = NO;
    self.videoCamera.delegate = self;
    
    [self createBackgroundSubstructors];
}

#pragma mark - Protocol CvVideoCameraDelegate

#ifdef __cplusplus

- (void)createBackgroundSubstructors {
    //create Background Subtractor objects
    //pMOG = new BackgroundSubtractorMOG(); //MOG approach
    pMOG2 = new BackgroundSubtractorMOG2(); //MOG2 approach
}

- (void)processImage:(Mat&)image {
    Mat gray;
    cvtColor(image, gray, COLOR_BGR2GRAY);
    
    Mat ret, thresh;
    threshold(gray, ret, 0, 255,  THRESH_BINARY_INV + THRESH_OTSU);
    threshold(gray, thresh, 0, 255,  THRESH_BINARY_INV + THRESH_OTSU);
    
    //noise removal
    Mat kernel(3, 3, CV_8UC1);
    Mat opening;
    morphologyEx(thresh, opening, MORPH_OPEN, kernel);
    
    //sure background area
    Mat sure_bg;
    dilate(opening, sure_bg, kernel);
    
    //Finding sure foreground area
    Mat dist_transform, sure_fg;
    distanceTransform(opening, dist_transform, CV_DIST_L2, 5);

    double dist_min, dist_max;
    minMaxLoc(dist_transform, &dist_min, &dist_max);
    
    threshold(dist_transform, ret, 0.7 * dist_max , 255, 0);
    threshold(dist_transform, sure_fg, 0.7 * dist_max , 255, 0);
    
    //Finding unknown region
    sure_fg.convertTo(sure_fg, CV_8UC1);
    
    Mat unknown;
    subtract(sure_bg, sure_fg, unknown);
    
    //Marker labelling
    vector<vector<cv::Point>> markers;
    
    findContours(sure_fg, markers, CV_RETR_LIST, CV_CHAIN_APPROX_SIMPLE);
    //findContours(sure_fg, ret, CV_RETR_LIST, CV_CHAIN_APPROX_SIMPLE);

    //Add one to all labels so that sure background is not 0, but 1
    //markers = markers + 1;
//    for (int i = 0; i < unknown.rows; i++) {
//        for (int j = 0; j < unknown.cols; j++) {
//            //markers.at(i) =;
//        }
//    }

    //Now, mark the region of unknown with zero
    //markers[unknown==255] = 0 //для всех индексов из unknown равных 255 makres по эти индексам будет присвоено 0;
//    for (int i = 0; i < unknown.rows; i++) {
//        for (int j = 0; j < unknown.cols; j++) {
//            if (unknown.at<unsigned>(i, j) == 255) {
//                //markers.at<unsigned>(i, j) = 0;
//            }
//        }
//    }
    Mat _markers = Mat(markers);
    _markers.convertTo(_markers, CV_32S);
   // cvtColor(image , image, COLOR_BGRA2BGR);

    watershed(image, _markers);
//
//    for (int i = 0; i < unknown.rows; i++) {
//        for (int j = 0; j < unknown.cols; j++) {
//            if (markers.at<unsigned>(i, j) == -1) {
//                //image.at<unsigned>(i, j) = [255,0,0];
//            }
//        }
//    }
//
//    //img[markers == -1] = [255,0,0]; !!!
    
    
//    CascadeClassifier face_detector;
//    CascadeClassifier shoulder_detector;
//    CascadeClassifier palm_detector;
//    CascadeClassifier cubit_detector; // локти
//    CascadeClassifier elbow_dector; //колени
//    CascadeClassifier belt_detector;
//    CascadeClassifier feet_detector;
//    
//    //подгрузил классификатор
//    
//    //рабочее изображение
//    Mat img;
//    equalizeHist(image, img);
//    
//    //массивы для хранения обнаруженных объектов
//    vector<cv::Rect> faces, shoulders, palms, cubits, elbows, belts, feets;
//    
//    //поиск необходимых объектов
//    face_detector.detectMultiScale(img, faces);
//    shoulder_detector.detectMultiScale(img, shoulders);
//    palm_detector.detectMultiScale(img, palms);
//    cubit_detector.detectMultiScale(img, cubits);
//    elbow_dector.detectMultiScale(img, elbows);
//    belt_detector.detectMultiScale(img, belts);
//    feet_detector.detectMultiScale(img, feets);
//
//    //отображение на экране и преобрзование для анимации объекта
//    for (size_t i = 0; i < faces.size(); i++) {
//        ellipse(img, [self centerFromRect:faces[i]], cv::Size(faces[i].width / 1.5, faces[i].height / 1.5), 0, 0, 360, cv::Scalar(255, 0, 255));
//        [self.avc moveHead:faces[i]];
//    }
//    for (size_t i = 0; i < shoulders.size(); i++) {
//        ellipse(img, [self centerFromRect:shoulders[i]], cv::Size(shoulders[i].width / 1.5, shoulders[i].height / 1.5), 0, 0, 360, cv::Scalar(255, 0, 255));
//        [self.avc moveShoulder:shoulders[i]];
//    }
//    for (size_t i = 0; i < palms.size(); i++) {
//        ellipse(img, [self centerFromRect:palms[i]], cv::Size(palms[i].width / 1.5, palms[i].height / 1.5), 0, 0, 360, cv::Scalar(255, 0, 255));
//        [self.avc movePalm:palms[i]];
//    }
//    for (size_t i = 0; i < cubits.size(); i++) {
//        ellipse(img, [self centerFromRect:cubits[i]], cv::Size(cubits[i].width / 1.5, cubits[i].height / 1.5), 0, 0, 360, cv::Scalar(255, 0, 255));
//        [self.avc moveCubit:cubits[i]];
//    }
//    for (size_t i = 0; i < elbows.size(); i++) {
//        ellipse(img, [self centerFromRect:elbows[i]], cv::Size(elbows[i].width / 1.5, elbows[i].height / 1.5), 0, 0, 360, cv::Scalar(255, 0, 255));
//        [self.avc moveElbow:elbows[i]];
//
//    }
//    for (size_t i = 0; i < belts.size(); i++) {
//        ellipse(img, [self centerFromRect:belts[i]], cv::Size(belts[i].width, belts[i].height / 1.5), 0, 0, 360, cv::Scalar(255, 0, 255));
//        [self.avc moveBelt:belts[i]];
//
//    }
//    for (size_t i = 0; i < feets.size(); i++) {
//        ellipse(img, [self centerFromRect:feets[i]], cv::Size(feets[i].width / 1.5, feets[i].height / 1.5), 0, 0, 360, cv::Scalar(255, 0, 255));
//        [self.avc moveFeet:feets[i]];
//    }
    
}

- (cv::Point)centerFromRect:(cv::Rect)rect {
    return cv::Point(rect.x + rect.width / 2, rect.y + rect.height / 2);
}

#endif

#pragma mark - UI Actions

- (IBAction)startCamera:(id)sender {
    [self.videoCamera start];
}

- (IBAction)stopCamera:(id)sender {
    [self.videoCamera stop];
}

@end
